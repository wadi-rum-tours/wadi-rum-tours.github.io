/* generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	add_flush_callback,
	add_render_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	check_outros,
	children,
	claim_component,
	claim_element,
	claim_space,
	claim_text,
	create_animation,
	create_bidirectional_transition,
	create_component,
	destroy_component,
	destroy_each,
	detach,
	element,
	empty,
	fix_and_outro_and_destroy_block,
	fix_position,
	group_outros,
	init,
	insert,
	is_function,
	listen,
	mount_component,
	noop,
	null_to_empty,
	prevent_default,
	run_all,
	safe_not_equal,
	set_data,
	set_input_value,
	space,
	svg_element,
	text,
	transition_in,
	transition_out,
	update_keyed_each
} from "svelte/internal";

import { isDate, makeDate, formatDate } from "./dates.js";

// Accordion
import { slide } from "svelte/transition";

// Drag and drop
import { flip } from "svelte/animate";

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[55] = list[i][0];
	child_ctx[53] = list[i][1];
	child_ctx[56] = list;
	child_ctx[57] = i;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[53] = list[i];
	child_ctx[54] = list;
	child_ctx[55] = i;
	return child_ctx;
}

// (262:49) 
function create_if_block_11(ctx) {
	let fieldset;
	let current;
	let each_value_1 = Object.entries(/*field*/ ctx[0]);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			fieldset = element("fieldset");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
		},
		l(nodes) {
			fieldset = claim_element(nodes, "FIELDSET", {});
			var fieldset_nodes = children(fieldset);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(fieldset_nodes);
			}

			fieldset_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert(target, fieldset, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(fieldset, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*field*/ 1) {
				each_value_1 = Object.entries(/*field*/ ctx[0]);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(fieldset, null);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(fieldset);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (179:47) 
function create_if_block_6(ctx) {
	let main;
	let div0;
	let p;
	let div0_class_value;
	let div0_style_value;
	let t;
	let div1;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	let mounted;
	let dispose;
	let each_value = /*field*/ ctx[0];

	const get_key = ctx => /*compID*/ ctx[16] = /*isOpen*/ ctx[3]
	? /*key*/ ctx[55]
	: /*value*/ ctx[53].constructor === ({}).constructor
		? /*value*/ ctx[53][Object.keys(/*value*/ ctx[53])[0]]
		: /*value*/ ctx[53];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			main = element("main");
			div0 = element("div");
			p = element("p");
			t = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l(nodes) {
			main = claim_element(nodes, "MAIN", { class: true });
			var main_nodes = children(main);
			div0 = claim_element(main_nodes, "DIV", { id: true, class: true, style: true });
			var div0_nodes = children(div0);
			p = claim_element(div0_nodes, "P", { class: true });
			children(p).forEach(detach);
			div0_nodes.forEach(detach);
			t = claim_space(main_nodes);
			div1 = claim_element(main_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div1_nodes);
			}

			div1_nodes.forEach(detach);
			main_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(p, "class", "svelte-1stajiv");
			attr(div0, "id", "ghost");
			attr(div0, "class", div0_class_value = "" + (null_to_empty(/*grabbed*/ ctx[6] ? "item haunting" : "item") + " svelte-1stajiv"));
			attr(div0, "style", div0_style_value = "top: " + (/*mouseY*/ ctx[7] + /*offsetY*/ ctx[8] - /*layerY*/ ctx[9]) + "px");
			attr(div1, "class", "list svelte-1stajiv");
			attr(main, "class", "dragdroplist svelte-1stajiv");
		},
		m(target, anchor) {
			insert(target, main, anchor);
			append(main, div0);
			append(div0, p);
			/*div0_binding*/ ctx[38](div0);
			append(main, t);
			append(main, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(div1, "mousemove", /*mousemove_handler*/ ctx[47]),
					listen(div1, "touchmove", /*touchmove_handler_1*/ ctx[48]),
					listen(div1, "mouseup", /*mouseup_handler*/ ctx[49]),
					listen(div1, "touchend", /*touchend_handler*/ ctx[50])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (!current || dirty[0] & /*grabbed*/ 64 && div0_class_value !== (div0_class_value = "" + (null_to_empty(/*grabbed*/ ctx[6] ? "item haunting" : "item") + " svelte-1stajiv"))) {
				attr(div0, "class", div0_class_value);
			}

			if (!current || dirty[0] & /*mouseY, offsetY, layerY*/ 896 && div0_style_value !== (div0_style_value = "top: " + (/*mouseY*/ ctx[7] + /*offsetY*/ ctx[8] - /*layerY*/ ctx[9]) + "px")) {
				attr(div0, "style", div0_style_value);
			}

			if (dirty[0] & /*grabbed, compID, field, label, openKeys, removeItem, removesItems, accordion, moveItem, grab, dragEnter, touchEnter, isOpen*/ 12288095) {
				each_value = /*field*/ ctx[0];
				group_outros();
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div1, fix_and_outro_and_destroy_block, create_each_block, null, get_each_context);
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(main);
			/*div0_binding*/ ctx[38](null);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (177:49) 
function create_if_block_5(ctx) {
	let input;
	let span;
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			span = element("span");
			t = text(/*field*/ ctx[0]);
			this.h();
		},
		l(nodes) {
			input = claim_element(nodes, "INPUT", { id: true, type: true, class: true });
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, /*field*/ ctx[0]);
			span_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(input, "id", /*label*/ ctx[1]);
			attr(input, "type", "checkbox");
			attr(input, "class", "svelte-1stajiv");
		},
		m(target, anchor) {
			insert(target, input, anchor);
			input.checked = /*field*/ ctx[0];
			insert(target, span, anchor);
			append(span, t);

			if (!mounted) {
				dispose = listen(input, "change", /*input_change_handler*/ ctx[37]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*label*/ 2) {
				attr(input, "id", /*label*/ ctx[1]);
			}

			if (dirty[0] & /*field*/ 1) {
				input.checked = /*field*/ ctx[0];
			}

			if (dirty[0] & /*field*/ 1) set_data(t, /*field*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(input);
			if (detaching) detach(span);
			mounted = false;
			dispose();
		}
	};
}

// (108:47) 
function create_if_block_2(ctx) {
	let show_if;
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (show_if == null || dirty[0] & /*field*/ 1) show_if = !!isDate(/*field*/ ctx[0]);
		if (show_if) return create_if_block_3;
		if (/*field*/ ctx[0].length < 50) return create_if_block_4;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx, [-1, -1]);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (106:30) 
function create_if_block_1(ctx) {
	let div;
	let t0;
	let t1;

	return {
		c() {
			div = element("div");
			t0 = text(/*field*/ ctx[0]);
			t1 = text(" is undefined");
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, /*field*/ ctx[0]);
			t1 = claim_text(div_nodes, " is undefined");
			div_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t0);
			append(div, t1);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*field*/ 1) set_data(t0, /*field*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (104:0) {#if field === null}
function create_if_block(ctx) {
	let div;
	let t0;
	let t1;

	return {
		c() {
			div = element("div");
			t0 = text(/*field*/ ctx[0]);
			t1 = text(" is null");
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, /*field*/ ctx[0]);
			t1 = claim_text(div_nodes, " is null");
			div_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t0);
			append(div, t1);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*field*/ 1) set_data(t0, /*field*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (265:8) {#each Object.entries(field) as [key, value]}
function create_each_block_1(ctx) {
	let div;
	let label_1;
	let t0_value = /*key*/ ctx[55] + "";
	let t0;
	let label_1_for_value;
	let t1;
	let component;
	let updating_field;
	let t2;
	let current;

	function component_field_binding_1(value) {
		/*component_field_binding_1*/ ctx[51](value, /*key*/ ctx[55]);
	}

	let component_props = { label: /*key*/ ctx[55] };

	if (/*field*/ ctx[0][/*key*/ ctx[55]] !== void 0) {
		component_props.field = /*field*/ ctx[0][/*key*/ ctx[55]];
	}

	component = new Component({ props: component_props });
	binding_callbacks.push(() => bind(component, "field", component_field_binding_1));

	return {
		c() {
			div = element("div");
			label_1 = element("label");
			t0 = text(t0_value);
			t1 = space();
			create_component(component.$$.fragment);
			t2 = space();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			label_1 = claim_element(div_nodes, "LABEL", { for: true, class: true });
			var label_1_nodes = children(label_1);
			t0 = claim_text(label_1_nodes, t0_value);
			label_1_nodes.forEach(detach);
			t1 = claim_space(div_nodes);
			claim_component(component.$$.fragment, div_nodes);
			t2 = claim_space(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(label_1, "for", label_1_for_value = /*key*/ ctx[55]);
			attr(label_1, "class", "svelte-1stajiv");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, label_1);
			append(label_1, t0);
			append(div, t1);
			mount_component(component, div, null);
			append(div, t2);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty[0] & /*field*/ 1) && t0_value !== (t0_value = /*key*/ ctx[55] + "")) set_data(t0, t0_value);

			if (!current || dirty[0] & /*field*/ 1 && label_1_for_value !== (label_1_for_value = /*key*/ ctx[55])) {
				attr(label_1, "for", label_1_for_value);
			}

			const component_changes = {};
			if (dirty[0] & /*field*/ 1) component_changes.label = /*key*/ ctx[55];

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				component_changes.field = /*field*/ ctx[0][/*key*/ ctx[55]];
				add_flush_callback(() => updating_field = false);
			}

			component.$set(component_changes);
		},
		i(local) {
			if (current) return;
			transition_in(component.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(component.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(component);
		}
	};
}

// (239:20) {:else}
function create_else_block_1(ctx) {
	let t0;
	let t1_value = /*key*/ ctx[55] + "";
	let t1;

	return {
		c() {
			t0 = text("Component ");
			t1 = text(t1_value);
		},
		l(nodes) {
			t0 = claim_text(nodes, "Component ");
			t1 = claim_text(nodes, t1_value);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*field*/ 1 && t1_value !== (t1_value = /*key*/ ctx[55] + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
		}
	};
}

// (237:69) 
function create_if_block_10(ctx) {
	let t_value = (Object.values(/*value*/ ctx[53])[0].constructor === ("").constructor
	? Object.values(/*value*/ ctx[53])[0].replace(/<[^>]*>?/gm, "").slice(0, 20).concat(/*value*/ ctx[53].length > 20 ? "..." : "")
	: Object.keys(/*value*/ ctx[53])[0]) + "";

	let t;

	return {
		c() {
			t = text(t_value);
		},
		l(nodes) {
			t = claim_text(nodes, t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*field*/ 1 && t_value !== (t_value = (Object.values(/*value*/ ctx[53])[0].constructor === ("").constructor
			? Object.values(/*value*/ ctx[53])[0].replace(/<[^>]*>?/gm, "").slice(0, 20).concat(/*value*/ ctx[53].length > 20 ? "..." : "")
			: Object.keys(/*value*/ ctx[53])[0]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (235:20) {#if value.constructor === "".constructor}
function create_if_block_9(ctx) {
	let t_value = /*value*/ ctx[53].replace(/<[^>]*>?/gm, "").slice(0, 20).concat(/*value*/ ctx[53].length > 20 ? "..." : "") + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		l(nodes) {
			t = claim_text(nodes, t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*field*/ 1 && t_value !== (t_value = /*value*/ ctx[53].replace(/<[^>]*>?/gm, "").slice(0, 20).concat(/*value*/ ctx[53].length > 20 ? "..." : "") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (245:20) {#if removesItems}
function create_if_block_8(ctx) {
	let button;
	let svg;
	let path0;
	let path1;
	let mounted;
	let dispose;

	function click_handler_10() {
		return /*click_handler_10*/ ctx[45](/*value*/ ctx[53]);
	}

	return {
		c() {
			button = element("button");
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);

			svg = claim_element(
				button_nodes,
				"svg",
				{
					xmlns: true,
					height: true,
					viewBox: true,
					width: true
				},
				1
			);

			var svg_nodes = children(svg);
			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
			children(path0).forEach(detach);
			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path1).forEach(detach);
			svg_nodes.forEach(detach);
			button_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(path1, "d", "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "height", "16");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "width", "16");
			attr(button, "class", "svelte-1stajiv");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, svg);
			append(svg, path0);
			append(svg, path1);

			if (!mounted) {
				dispose = listen(button, "click", prevent_default(click_handler_10));
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (253:12) {#if openKeys.includes(key)}
function create_if_block_7(ctx) {
	let div;
	let component;
	let updating_field;
	let div_transition;
	let current;

	function component_field_binding(value) {
		/*component_field_binding*/ ctx[46](value, /*key*/ ctx[55]);
	}

	let component_props = { label: /*label*/ ctx[1] };

	if (/*field*/ ctx[0][/*key*/ ctx[55]] !== void 0) {
		component_props.field = /*field*/ ctx[0][/*key*/ ctx[55]];
	}

	component = new Component({ props: component_props });
	binding_callbacks.push(() => bind(component, "field", component_field_binding));

	return {
		c() {
			div = element("div");
			create_component(component.$$.fragment);
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(component.$$.fragment, div_nodes);
			div_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(component, div, null);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const component_changes = {};
			if (dirty[0] & /*label*/ 2) component_changes.label = /*label*/ ctx[1];

			if (!updating_field && dirty[0] & /*field*/ 1) {
				updating_field = true;
				component_changes.field = /*field*/ ctx[0][/*key*/ ctx[55]];
				add_flush_callback(() => updating_field = false);
			}

			component.$set(component_changes);
		},
		i(local) {
			if (current) return;
			transition_in(component.$$.fragment, local);

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, true);
				div_transition.run(1);
			});

			current = true;
		},
		o(local) {
			transition_out(component.$$.fragment, local);
			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, false);
			div_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(component);
			if (detaching && div_transition) div_transition.end();
		}
	};
}

// (192:8) {#each field as value, key (compID = isOpen ? key : value.constructor === ({}
function create_each_block(key_2, ctx) {
	let div5;
	let div4;
	let div0;
	let svg0;
	let path0;
	let circle0;
	let circle1;
	let circle2;
	let circle3;
	let circle4;
	let circle5;
	let t0;
	let div1;
	let button0;
	let svg1;
	let path1;
	let path2;
	let button0_style_value;
	let t1;
	let button1;
	let svg2;
	let path3;
	let path4;
	let button1_style_value;
	let t2;
	let div2;
	let t3;
	let div3;
	let t4;
	let show_if = /*openKeys*/ ctx[4].includes(/*key*/ ctx[55]);
	let t5;
	let div5_id_value;
	let div5_data_index_value;
	let rect;
	let stop_animation = noop;
	let current;
	let mounted;
	let dispose;

	function click_handler_8(...args) {
		return /*click_handler_8*/ ctx[43](/*key*/ ctx[55], ...args);
	}

	function click_handler_9(...args) {
		return /*click_handler_9*/ ctx[44](/*key*/ ctx[55], ...args);
	}

	function select_block_type_2(ctx, dirty) {
		if (/*value*/ ctx[53].constructor === ("").constructor) return create_if_block_9;
		if (/*value*/ ctx[53].constructor === ({}).constructor) return create_if_block_10;
		return create_else_block_1;
	}

	let current_block_type = select_block_type_2(ctx, [-1, -1]);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*removesItems*/ ctx[2] && create_if_block_8(ctx);
	let if_block2 = show_if && create_if_block_7(ctx);

	return {
		key: key_2,
		first: null,
		c() {
			div5 = element("div");
			div4 = element("div");
			div0 = element("div");
			svg0 = svg_element("svg");
			path0 = svg_element("path");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			circle3 = svg_element("circle");
			circle4 = svg_element("circle");
			circle5 = svg_element("circle");
			t0 = space();
			div1 = element("div");
			button0 = element("button");
			svg1 = svg_element("svg");
			path1 = svg_element("path");
			path2 = svg_element("path");
			t1 = space();
			button1 = element("button");
			svg2 = svg_element("svg");
			path3 = svg_element("path");
			path4 = svg_element("path");
			t2 = space();
			div2 = element("div");
			if_block0.c();
			t3 = space();
			div3 = element("div");
			if (if_block1) if_block1.c();
			t4 = space();
			if (if_block2) if_block2.c();
			t5 = space();
			this.h();
		},
		l(nodes) {
			div5 = claim_element(nodes, "DIV", {
				id: true,
				"data-index": true,
				"data-id": true,
				"data-graby": true,
				class: true
			});

			var div5_nodes = children(div5);
			div4 = claim_element(div5_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div0 = claim_element(div4_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			svg0 = claim_element(
				div0_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg0_nodes = children(svg0);
			path0 = claim_element(svg0_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path0).forEach(detach);
			circle0 = claim_element(svg0_nodes, "circle", { cx: true, cy: true, r: true }, 1);
			children(circle0).forEach(detach);
			circle1 = claim_element(svg0_nodes, "circle", { cx: true, cy: true, r: true }, 1);
			children(circle1).forEach(detach);
			circle2 = claim_element(svg0_nodes, "circle", { cx: true, cy: true, r: true }, 1);
			children(circle2).forEach(detach);
			circle3 = claim_element(svg0_nodes, "circle", { cx: true, cy: true, r: true }, 1);
			children(circle3).forEach(detach);
			circle4 = claim_element(svg0_nodes, "circle", { cx: true, cy: true, r: true }, 1);
			children(circle4).forEach(detach);
			circle5 = claim_element(svg0_nodes, "circle", { cx: true, cy: true, r: true }, 1);
			children(circle5).forEach(detach);
			svg0_nodes.forEach(detach);
			div0_nodes.forEach(detach);
			t0 = claim_space(div4_nodes);
			div1 = claim_element(div4_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			button0 = claim_element(div1_nodes, "BUTTON", { class: true, style: true });
			var button0_nodes = children(button0);

			svg1 = claim_element(
				button0_nodes,
				"svg",
				{
					xmlns: true,
					viewBox: true,
					width: true,
					height: true
				},
				1
			);

			var svg1_nodes = children(svg1);
			path1 = claim_element(svg1_nodes, "path", { d: true, fill: true }, 1);
			children(path1).forEach(detach);
			path2 = claim_element(svg1_nodes, "path", { d: true }, 1);
			children(path2).forEach(detach);
			svg1_nodes.forEach(detach);
			button0_nodes.forEach(detach);
			t1 = claim_space(div1_nodes);
			button1 = claim_element(div1_nodes, "BUTTON", { class: true, style: true });
			var button1_nodes = children(button1);

			svg2 = claim_element(
				button1_nodes,
				"svg",
				{
					xmlns: true,
					viewBox: true,
					width: true,
					height: true
				},
				1
			);

			var svg2_nodes = children(svg2);
			path3 = claim_element(svg2_nodes, "path", { d: true, fill: true }, 1);
			children(path3).forEach(detach);
			path4 = claim_element(svg2_nodes, "path", { d: true }, 1);
			children(path4).forEach(detach);
			svg2_nodes.forEach(detach);
			button1_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			t2 = claim_space(div4_nodes);
			div2 = claim_element(div4_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			if_block0.l(div2_nodes);
			div2_nodes.forEach(detach);
			t3 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			if (if_block1) if_block1.l(div3_nodes);
			div3_nodes.forEach(detach);
			div4_nodes.forEach(detach);
			t4 = claim_space(div5_nodes);
			if (if_block2) if_block2.l(div5_nodes);
			t5 = claim_space(div5_nodes);
			div5_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path0, "stroke", "none");
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(circle0, "cx", "5");
			attr(circle0, "cy", "9");
			attr(circle0, "r", "1");
			attr(circle1, "cx", "5");
			attr(circle1, "cy", "15");
			attr(circle1, "r", "1");
			attr(circle2, "cx", "12");
			attr(circle2, "cy", "9");
			attr(circle2, "r", "1");
			attr(circle3, "cx", "12");
			attr(circle3, "cy", "15");
			attr(circle3, "r", "1");
			attr(circle4, "cx", "19");
			attr(circle4, "cy", "9");
			attr(circle4, "r", "1");
			attr(circle5, "cx", "19");
			attr(circle5, "cy", "15");
			attr(circle5, "r", "1");
			attr(svg0, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg0, "class", "icon icon-tabler icon-tabler-grip-horizontal");
			attr(svg0, "width", "30");
			attr(svg0, "height", "30");
			attr(svg0, "viewBox", "0 0 24 24");
			attr(svg0, "stroke-width", "1.5");
			attr(svg0, "stroke", "#2c3e50");
			attr(svg0, "fill", "none");
			attr(svg0, "stroke-linecap", "round");
			attr(svg0, "stroke-linejoin", "round");
			attr(div0, "class", "grip svelte-1stajiv");
			attr(path1, "d", "M0 0h24v24H0V0z");
			attr(path1, "fill", "none");
			attr(path2, "d", "M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6 1.41 1.41z");
			attr(svg1, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg1, "viewBox", "0 0 24 24");
			attr(svg1, "width", "16px");
			attr(svg1, "height", "16px");
			attr(button0, "class", "up svelte-1stajiv");
			attr(button0, "style", button0_style_value = "visibility: " + (/*key*/ ctx[55] > 0 ? "" : "hidden") + ";");
			attr(path3, "d", "M0 0h24v24H0V0z");
			attr(path3, "fill", "none");
			attr(path4, "d", "M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z");
			attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg2, "viewBox", "0 0 24 24");
			attr(svg2, "width", "16px");
			attr(svg2, "height", "16px");
			attr(button1, "class", "down svelte-1stajiv");

			attr(button1, "style", button1_style_value = "visibility: " + (/*key*/ ctx[55] < /*field*/ ctx[0].length - 1
			? ""
			: "hidden") + ";");

			attr(div1, "class", "buttons svelte-1stajiv");
			attr(div2, "class", "content svelte-1stajiv");
			attr(div3, "class", "buttons svelte-1stajiv");
			attr(div4, "class", "item svelte-1stajiv");

			attr(div5, "id", div5_id_value = /*grabbed*/ ctx[6] && /*compID*/ ctx[16] == /*grabbed*/ ctx[6].dataset.id
			? "grabbed"
			: "");

			attr(div5, "data-index", div5_data_index_value = /*key*/ ctx[55]);
			attr(div5, "data-id", /*compID*/ ctx[16]);
			attr(div5, "data-graby", "0");
			attr(div5, "class", "item-wrapper svelte-1stajiv");
			this.first = div5;
		},
		m(target, anchor) {
			insert(target, div5, anchor);
			append(div5, div4);
			append(div4, div0);
			append(div0, svg0);
			append(svg0, path0);
			append(svg0, circle0);
			append(svg0, circle1);
			append(svg0, circle2);
			append(svg0, circle3);
			append(svg0, circle4);
			append(svg0, circle5);
			append(div4, t0);
			append(div4, div1);
			append(div1, button0);
			append(button0, svg1);
			append(svg1, path1);
			append(svg1, path2);
			append(div1, t1);
			append(div1, button1);
			append(button1, svg2);
			append(svg2, path3);
			append(svg2, path4);
			append(div4, t2);
			append(div4, div2);
			if_block0.m(div2, null);
			append(div4, t3);
			append(div4, div3);
			if (if_block1) if_block1.m(div3, null);
			append(div5, t4);
			if (if_block2) if_block2.m(div5, null);
			append(div5, t5);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div0, "mousedown", /*mousedown_handler*/ ctx[39]),
					listen(div0, "touchstart", /*touchstart_handler*/ ctx[40]),
					listen(div0, "mouseenter", /*mouseenter_handler*/ ctx[41]),
					listen(div0, "touchmove", /*touchmove_handler*/ ctx[42]),
					listen(button0, "click", prevent_default(click_handler_8)),
					listen(button1, "click", prevent_default(click_handler_9)),
					listen(div2, "click", prevent_default(function () {
						if (is_function(/*accordion*/ ctx[15](/*key*/ ctx[55]))) /*accordion*/ ctx[15](/*key*/ ctx[55]).apply(this, arguments);
					}))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (!current || dirty[0] & /*field*/ 1 && button0_style_value !== (button0_style_value = "visibility: " + (/*key*/ ctx[55] > 0 ? "" : "hidden") + ";")) {
				attr(button0, "style", button0_style_value);
			}

			if (!current || dirty[0] & /*field*/ 1 && button1_style_value !== (button1_style_value = "visibility: " + (/*key*/ ctx[55] < /*field*/ ctx[0].length - 1
			? ""
			: "hidden") + ";")) {
				attr(button1, "style", button1_style_value);
			}

			if (current_block_type === (current_block_type = select_block_type_2(ctx, dirty)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div2, null);
				}
			}

			if (/*removesItems*/ ctx[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_8(ctx);
					if_block1.c();
					if_block1.m(div3, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*openKeys, field*/ 17) show_if = /*openKeys*/ ctx[4].includes(/*key*/ ctx[55]);

			if (show_if) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*openKeys, field*/ 17) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_7(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div5, t5);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*grabbed*/ 64 && div5_id_value !== (div5_id_value = /*grabbed*/ ctx[6] && /*compID*/ ctx[16] == /*grabbed*/ ctx[6].dataset.id
			? "grabbed"
			: "")) {
				attr(div5, "id", div5_id_value);
			}

			if (!current || dirty[0] & /*field*/ 1 && div5_data_index_value !== (div5_data_index_value = /*key*/ ctx[55])) {
				attr(div5, "data-index", div5_data_index_value);
			}
		},
		r() {
			rect = div5.getBoundingClientRect();
		},
		f() {
			fix_position(div5);
			stop_animation();
		},
		a() {
			stop_animation();
			stop_animation = create_animation(div5, rect, flip, { duration: /*isOpen*/ ctx[3] ? null : 200 });
		},
		i(local) {
			if (current) return;
			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div5);
			if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (113:4) {:else}
function create_else_block(ctx) {
	let div3;
	let button0;
	let b;
	let t0;
	let t1;
	let button1;
	let i;
	let t2;
	let t3;
	let button2;
	let u;
	let t4;
	let t5;
	let div0;
	let t6;
	let button3;
	let svg0;
	let path0;
	let path1;
	let path2;
	let path3;
	let circle0;
	let circle1;
	let t7;
	let button4;
	let svg1;
	let path4;
	let path5;
	let path6;
	let path7;
	let path8;
	let path9;
	let t8;
	let div1;
	let t9;
	let button5;
	let svg2;
	let path10;
	let path11;
	let path12;
	let t10;
	let button6;
	let svg3;
	let path13;
	let path14;
	let path15;
	let line0;
	let line1;
	let line2;
	let line3;
	let t11;
	let div2;
	let t12;
	let button7;
	let svg4;
	let path16;
	let path17;
	let path18;
	let line4;
	let line5;
	let t13;
	let div4;
	let mounted;
	let dispose;

	return {
		c() {
			div3 = element("div");
			button0 = element("button");
			b = element("b");
			t0 = text("B");
			t1 = space();
			button1 = element("button");
			i = element("i");
			t2 = text("I");
			t3 = space();
			button2 = element("button");
			u = element("u");
			t4 = text("U");
			t5 = space();
			div0 = element("div");
			t6 = space();
			button3 = element("button");
			svg0 = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			t7 = space();
			button4 = element("button");
			svg1 = svg_element("svg");
			path4 = svg_element("path");
			path5 = svg_element("path");
			path6 = svg_element("path");
			path7 = svg_element("path");
			path8 = svg_element("path");
			path9 = svg_element("path");
			t8 = space();
			div1 = element("div");
			t9 = space();
			button5 = element("button");
			svg2 = svg_element("svg");
			path10 = svg_element("path");
			path11 = svg_element("path");
			path12 = svg_element("path");
			t10 = space();
			button6 = element("button");
			svg3 = svg_element("svg");
			path13 = svg_element("path");
			path14 = svg_element("path");
			path15 = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			t11 = space();
			div2 = element("div");
			t12 = space();
			button7 = element("button");
			svg4 = svg_element("svg");
			path16 = svg_element("path");
			path17 = svg_element("path");
			path18 = svg_element("path");
			line4 = svg_element("line");
			line5 = svg_element("line");
			t13 = space();
			div4 = element("div");
			this.h();
		},
		l(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			button0 = claim_element(div3_nodes, "BUTTON", { title: true, class: true });
			var button0_nodes = children(button0);
			b = claim_element(button0_nodes, "B", {});
			var b_nodes = children(b);
			t0 = claim_text(b_nodes, "B");
			b_nodes.forEach(detach);
			button0_nodes.forEach(detach);
			t1 = claim_space(div3_nodes);
			button1 = claim_element(div3_nodes, "BUTTON", { title: true, class: true });
			var button1_nodes = children(button1);
			i = claim_element(button1_nodes, "I", {});
			var i_nodes = children(i);
			t2 = claim_text(i_nodes, "I");
			i_nodes.forEach(detach);
			button1_nodes.forEach(detach);
			t3 = claim_space(div3_nodes);
			button2 = claim_element(div3_nodes, "BUTTON", { title: true, class: true });
			var button2_nodes = children(button2);
			u = claim_element(button2_nodes, "U", {});
			var u_nodes = children(u);
			t4 = claim_text(u_nodes, "U");
			u_nodes.forEach(detach);
			button2_nodes.forEach(detach);
			t5 = claim_space(div3_nodes);
			div0 = claim_element(div3_nodes, "DIV", { class: true });
			children(div0).forEach(detach);
			t6 = claim_space(div3_nodes);
			button3 = claim_element(div3_nodes, "BUTTON", { class: true });
			var button3_nodes = children(button3);

			svg0 = claim_element(
				button3_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg0_nodes = children(svg0);
			path0 = claim_element(svg0_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path0).forEach(detach);
			path1 = claim_element(svg0_nodes, "path", { d: true }, 1);
			children(path1).forEach(detach);
			path2 = claim_element(svg0_nodes, "path", { d: true }, 1);
			children(path2).forEach(detach);
			path3 = claim_element(svg0_nodes, "path", { d: true }, 1);
			children(path3).forEach(detach);
			circle0 = claim_element(svg0_nodes, "circle", { cx: true, r: true, cy: true }, 1);
			children(circle0).forEach(detach);
			circle1 = claim_element(svg0_nodes, "circle", { cx: true, r: true, cy: true }, 1);
			children(circle1).forEach(detach);
			svg0_nodes.forEach(detach);
			button3_nodes.forEach(detach);
			t7 = claim_space(div3_nodes);
			button4 = claim_element(div3_nodes, "BUTTON", { class: true });
			var button4_nodes = children(button4);

			svg1 = claim_element(
				button4_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg1_nodes = children(svg1);
			path4 = claim_element(svg1_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path4).forEach(detach);
			path5 = claim_element(svg1_nodes, "path", { d: true }, 1);
			children(path5).forEach(detach);
			path6 = claim_element(svg1_nodes, "path", { d: true }, 1);
			children(path6).forEach(detach);
			path7 = claim_element(svg1_nodes, "path", { d: true }, 1);
			children(path7).forEach(detach);
			path8 = claim_element(svg1_nodes, "path", { d: true }, 1);
			children(path8).forEach(detach);
			path9 = claim_element(svg1_nodes, "path", { d: true }, 1);
			children(path9).forEach(detach);
			svg1_nodes.forEach(detach);
			button4_nodes.forEach(detach);
			t8 = claim_space(div3_nodes);
			div1 = claim_element(div3_nodes, "DIV", { class: true });
			children(div1).forEach(detach);
			t9 = claim_space(div3_nodes);
			button5 = claim_element(div3_nodes, "BUTTON", { class: true });
			var button5_nodes = children(button5);

			svg2 = claim_element(
				button5_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg2_nodes = children(svg2);
			path10 = claim_element(svg2_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path10).forEach(detach);
			path11 = claim_element(svg2_nodes, "path", { d: true }, 1);
			children(path11).forEach(detach);
			path12 = claim_element(svg2_nodes, "path", { d: true }, 1);
			children(path12).forEach(detach);
			svg2_nodes.forEach(detach);
			button5_nodes.forEach(detach);
			t10 = claim_space(div3_nodes);
			button6 = claim_element(div3_nodes, "BUTTON", { class: true });
			var button6_nodes = children(button6);

			svg3 = claim_element(
				button6_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg3_nodes = children(svg3);
			path13 = claim_element(svg3_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path13).forEach(detach);
			path14 = claim_element(svg3_nodes, "path", { d: true }, 1);
			children(path14).forEach(detach);
			path15 = claim_element(svg3_nodes, "path", { d: true }, 1);
			children(path15).forEach(detach);
			line0 = claim_element(svg3_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line0).forEach(detach);
			line1 = claim_element(svg3_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line1).forEach(detach);
			line2 = claim_element(svg3_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line2).forEach(detach);
			line3 = claim_element(svg3_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line3).forEach(detach);
			svg3_nodes.forEach(detach);
			button6_nodes.forEach(detach);
			t11 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			children(div2).forEach(detach);
			t12 = claim_space(div3_nodes);
			button7 = claim_element(div3_nodes, "BUTTON", { class: true });
			var button7_nodes = children(button7);

			svg4 = claim_element(
				button7_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg4_nodes = children(svg4);
			path16 = claim_element(svg4_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path16).forEach(detach);
			path17 = claim_element(svg4_nodes, "path", { d: true }, 1);
			children(path17).forEach(detach);
			path18 = claim_element(svg4_nodes, "path", { d: true }, 1);
			children(path18).forEach(detach);
			line4 = claim_element(svg4_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line4).forEach(detach);
			line5 = claim_element(svg4_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line5).forEach(detach);
			svg4_nodes.forEach(detach);
			button7_nodes.forEach(detach);
			div3_nodes.forEach(detach);
			t13 = claim_space(nodes);

			div4 = claim_element(nodes, "DIV", {
				id: true,
				class: true,
				contenteditable: true
			});

			children(div4).forEach(detach);
			this.h();
		},
		h() {
			attr(button0, "title", "Bold the selected text");
			attr(button0, "class", "svelte-1stajiv");
			attr(button1, "title", "Italicize the selected text");
			attr(button1, "class", "svelte-1stajiv");
			attr(button2, "title", "Underline the selected text");
			attr(button2, "class", "svelte-1stajiv");
			attr(div0, "class", "spacer svelte-1stajiv");
			attr(path0, "stroke", "none");
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(path1, "d", "M11 6h9");
			attr(path2, "d", "M11 12h9");
			attr(path3, "d", "M12 18h8");
			attr(circle0, "cx", "5");
			attr(circle0, "r", "2");
			attr(circle0, "cy", "7");
			attr(circle1, "cx", "5");
			attr(circle1, "r", "2");
			attr(circle1, "cy", "17");
			attr(svg0, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg0, "class", "icon icon-tabler icon-tabler-list-numbers-MODIFIED svelte-1stajiv");
			attr(svg0, "width", "20");
			attr(svg0, "height", "20");
			attr(svg0, "viewBox", "0 0 24 24");
			attr(svg0, "stroke-width", "1.5");
			attr(svg0, "stroke", "black");
			attr(svg0, "fill", "none");
			attr(svg0, "stroke-linecap", "round");
			attr(svg0, "stroke-linejoin", "round");
			attr(button3, "class", "svelte-1stajiv");
			attr(path4, "stroke", "none");
			attr(path4, "d", "M0 0h24v24H0z");
			attr(path4, "fill", "none");
			attr(path5, "d", "M11 6h9");
			attr(path6, "d", "M11 12h9");
			attr(path7, "d", "M12 18h8");
			attr(path8, "d", "M4 16a2 2 0 1 1 4 0c0 .591 -.5 1 -1 1.5l-3 2.5h4");
			attr(path9, "d", "M6 10v-6l-2 2");
			attr(svg1, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg1, "class", "icon icon-tabler icon-tabler-list-numbers svelte-1stajiv");
			attr(svg1, "width", "20");
			attr(svg1, "height", "20");
			attr(svg1, "viewBox", "0 0 24 24");
			attr(svg1, "stroke-width", "1.5");
			attr(svg1, "stroke", "black");
			attr(svg1, "fill", "none");
			attr(svg1, "stroke-linecap", "round");
			attr(svg1, "stroke-linejoin", "round");
			attr(button4, "class", "svelte-1stajiv");
			attr(div1, "class", "spacer svelte-1stajiv");
			attr(path10, "stroke", "none");
			attr(path10, "d", "M0 0h24v24H0z");
			attr(path10, "fill", "none");
			attr(path11, "d", "M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5");
			attr(path12, "d", "M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5");
			attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg2, "class", "icon icon-tabler icon-tabler-link svelte-1stajiv");
			attr(svg2, "width", "20");
			attr(svg2, "height", "20");
			attr(svg2, "viewBox", "0 0 24 24");
			attr(svg2, "stroke-width", "1.5");
			attr(svg2, "stroke", "black");
			attr(svg2, "fill", "none");
			attr(svg2, "stroke-linecap", "round");
			attr(svg2, "stroke-linejoin", "round");
			attr(button5, "class", "svelte-1stajiv");
			attr(path13, "stroke", "none");
			attr(path13, "d", "M0 0h24v24H0z");
			attr(path13, "fill", "none");
			attr(path14, "d", "M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5");
			attr(path15, "d", "M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5");
			attr(line0, "x1", "16");
			attr(line0, "y1", "21");
			attr(line0, "x2", "16");
			attr(line0, "y2", "19");
			attr(line1, "x1", "19");
			attr(line1, "y1", "16");
			attr(line1, "x2", "21");
			attr(line1, "y2", "16");
			attr(line2, "x1", "3");
			attr(line2, "y1", "8");
			attr(line2, "x2", "5");
			attr(line2, "y2", "8");
			attr(line3, "x1", "8");
			attr(line3, "y1", "3");
			attr(line3, "x2", "8");
			attr(line3, "y2", "5");
			attr(svg3, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg3, "class", "icon icon-tabler icon-tabler-unlink svelte-1stajiv");
			attr(svg3, "width", "20");
			attr(svg3, "height", "20");
			attr(svg3, "viewBox", "0 0 24 24");
			attr(svg3, "stroke-width", "1.5");
			attr(svg3, "stroke", "black");
			attr(svg3, "fill", "none");
			attr(svg3, "stroke-linecap", "round");
			attr(svg3, "stroke-linejoin", "round");
			attr(button6, "class", "svelte-1stajiv");
			attr(div2, "class", "spacer svelte-1stajiv");
			attr(path16, "stroke", "none");
			attr(path16, "d", "M0 0h24v24H0z");
			attr(path16, "fill", "none");
			attr(path17, "d", "M17 15l4 4m0 -4l-4 4");
			attr(path18, "d", "M7 6v-1h11v1");
			attr(line4, "x1", "7");
			attr(line4, "y1", "19");
			attr(line4, "x2", "11");
			attr(line4, "y2", "19");
			attr(line5, "x1", "13");
			attr(line5, "y1", "5");
			attr(line5, "x2", "9");
			attr(line5, "y2", "19");
			attr(svg4, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg4, "class", "icon icon-tabler icon-tabler-clear-formatting svelte-1stajiv");
			attr(svg4, "width", "20");
			attr(svg4, "height", "20");
			attr(svg4, "viewBox", "0 0 24 24");
			attr(svg4, "stroke-width", "1.5");
			attr(svg4, "stroke", "black");
			attr(svg4, "fill", "none");
			attr(svg4, "stroke-linecap", "round");
			attr(svg4, "stroke-linejoin", "round");
			attr(button7, "class", "svelte-1stajiv");
			attr(div3, "class", "editor svelte-1stajiv");
			attr(div4, "id", /*label*/ ctx[1]);
			attr(div4, "class", "textarea svelte-1stajiv");
			attr(div4, "contenteditable", "true");
			if (/*field*/ ctx[0] === void 0) add_render_callback(() => /*div4_input_handler*/ ctx[35].call(div4));
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, button0);
			append(button0, b);
			append(b, t0);
			append(div3, t1);
			append(div3, button1);
			append(button1, i);
			append(i, t2);
			append(div3, t3);
			append(div3, button2);
			append(button2, u);
			append(u, t4);
			append(div3, t5);
			append(div3, div0);
			append(div3, t6);
			append(div3, button3);
			append(button3, svg0);
			append(svg0, path0);
			append(svg0, path1);
			append(svg0, path2);
			append(svg0, path3);
			append(svg0, circle0);
			append(svg0, circle1);
			append(div3, t7);
			append(div3, button4);
			append(button4, svg1);
			append(svg1, path4);
			append(svg1, path5);
			append(svg1, path6);
			append(svg1, path7);
			append(svg1, path8);
			append(svg1, path9);
			append(div3, t8);
			append(div3, div1);
			append(div3, t9);
			append(div3, button5);
			append(button5, svg2);
			append(svg2, path10);
			append(svg2, path11);
			append(svg2, path12);
			append(div3, t10);
			append(div3, button6);
			append(button6, svg3);
			append(svg3, path13);
			append(svg3, path14);
			append(svg3, path15);
			append(svg3, line0);
			append(svg3, line1);
			append(svg3, line2);
			append(svg3, line3);
			append(div3, t11);
			append(div3, div2);
			append(div3, t12);
			append(div3, button7);
			append(button7, svg4);
			append(svg4, path16);
			append(svg4, path17);
			append(svg4, path18);
			append(svg4, line4);
			append(svg4, line5);
			insert(target, t13, anchor);
			insert(target, div4, anchor);

			if (/*field*/ ctx[0] !== void 0) {
				div4.innerHTML = /*field*/ ctx[0];
			}

			/*div4_binding*/ ctx[36](div4);

			if (!mounted) {
				dispose = [
					listen(button0, "click", function () {
						if (is_function(/*textarea*/ ctx[10].focus())) /*textarea*/ ctx[10].focus().apply(this, arguments);
					}),
					listen(button0, "click", prevent_default(/*click_handler*/ ctx[27])),
					listen(button1, "click", function () {
						if (is_function(/*textarea*/ ctx[10].focus())) /*textarea*/ ctx[10].focus().apply(this, arguments);
					}),
					listen(button1, "click", prevent_default(/*click_handler_1*/ ctx[28])),
					listen(button2, "click", function () {
						if (is_function(/*textarea*/ ctx[10].focus())) /*textarea*/ ctx[10].focus().apply(this, arguments);
					}),
					listen(button2, "click", prevent_default(/*click_handler_2*/ ctx[29])),
					listen(button3, "click", function () {
						if (is_function(/*textarea*/ ctx[10].focus())) /*textarea*/ ctx[10].focus().apply(this, arguments);
					}),
					listen(button3, "click", prevent_default(/*click_handler_3*/ ctx[30])),
					listen(button4, "click", function () {
						if (is_function(/*textarea*/ ctx[10].focus())) /*textarea*/ ctx[10].focus().apply(this, arguments);
					}),
					listen(button4, "click", prevent_default(/*click_handler_4*/ ctx[31])),
					listen(button5, "click", function () {
						if (is_function(/*textarea*/ ctx[10].focus())) /*textarea*/ ctx[10].focus().apply(this, arguments);
					}),
					listen(button5, "click", /*createLink*/ ctx[24]),
					listen(button5, "click", prevent_default(/*click_handler_5*/ ctx[32])),
					listen(button6, "click", function () {
						if (is_function(/*textarea*/ ctx[10].focus())) /*textarea*/ ctx[10].focus().apply(this, arguments);
					}),
					listen(button6, "click", prevent_default(/*click_handler_6*/ ctx[33])),
					listen(button7, "click", function () {
						if (is_function(/*textarea*/ ctx[10].focus())) /*textarea*/ ctx[10].focus().apply(this, arguments);
					}),
					listen(button7, "click", prevent_default(/*click_handler_7*/ ctx[34])),
					listen(div4, "input", /*div4_input_handler*/ ctx[35])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*label*/ 2) {
				attr(div4, "id", /*label*/ ctx[1]);
			}

			if (dirty[0] & /*field*/ 1 && /*field*/ ctx[0] !== div4.innerHTML) {
				div4.innerHTML = /*field*/ ctx[0];
			}
		},
		d(detaching) {
			if (detaching) detach(div3);
			if (detaching) detach(t13);
			if (detaching) detach(div4);
			/*div4_binding*/ ctx[36](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (111:32) 
function create_if_block_4(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			this.h();
		},
		l(nodes) {
			input = claim_element(nodes, "INPUT", { id: true, type: true, class: true });
			this.h();
		},
		h() {
			attr(input, "id", /*label*/ ctx[1]);
			attr(input, "type", "text");
			attr(input, "class", "svelte-1stajiv");
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*field*/ ctx[0]);

			if (!mounted) {
				dispose = listen(input, "input", /*input_input_handler*/ ctx[26]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*label*/ 2) {
				attr(input, "id", /*label*/ ctx[1]);
			}

			if (dirty[0] & /*field*/ 1 && input.value !== /*field*/ ctx[0]) {
				set_input_value(input, /*field*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			dispose();
		}
	};
}

// (109:4) {#if isDate(field)}
function create_if_block_3(ctx) {
	let input;
	let input_value_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			this.h();
		},
		l(nodes) {
			input = claim_element(nodes, "INPUT", { type: true });
			this.h();
		},
		h() {
			attr(input, "type", "date");
			input.value = input_value_value = makeDate(/*field*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, input, anchor);

			if (!mounted) {
				dispose = listen(input, "input", /*input_handler*/ ctx[25]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*field*/ 1 && input_value_value !== (input_value_value = makeDate(/*field*/ ctx[0]))) {
				input.value = input_value_value;
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	const if_block_creators = [
		create_if_block,
		create_if_block_1,
		create_if_block_2,
		create_if_block_5,
		create_if_block_6,
		create_if_block_11
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*field*/ ctx[0] === null) return 0;
		if (/*field*/ ctx[0] === undefined) return 1;
		if (/*field*/ ctx[0].constructor === ("").constructor) return 2;
		if (/*field*/ ctx[0].constructor === (true).constructor) return 3;
		if (/*field*/ ctx[0].constructor === [].constructor) return 4;
		if (/*field*/ ctx[0].constructor === ({}).constructor) return 5;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, [-1, -1]))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { field } = $$props, { label } = $$props;

	const bindDate = date => {
		$$invalidate(0, field = formatDate(date, field));
	};

	let isOpen = false;
	let openKeys = [];

	const accordion = newKey => {
		if (openKeys.length === 1 && openKeys.includes(newKey)) {
			setTimeout(
				() => {
					$$invalidate(3, isOpen = false);
				},
				300
			);
		}

		if (openKeys.includes(newKey)) {
			// Remove key
			$$invalidate(4, openKeys = openKeys.filter(key => key !== newKey));
		} else {
			// Add key
			$$invalidate(4, openKeys = [...openKeys, newKey]);

			$$invalidate(3, isOpen = true);
		}
	};

	let { removesItems = true } = $$props;
	let compID;
	let ghost;
	let grabbed;
	let lastTarget;
	let mouseY = 0; // pointer y coordinate within client
	let offsetY = 0; // y distance from top of grabbed element to pointer
	let layerY = 0; // distance from top of list to top of client

	const grab = (clientY, element) => {
		// modify grabbed element
		$$invalidate(6, grabbed = element);

		$$invalidate(6, grabbed.dataset.grabY = clientY, grabbed);

		// modify ghost element (which is actually dragged)
		$$invalidate(5, ghost.innerHTML = grabbed.innerHTML, ghost);

		// record offset from cursor to top of element
		// (used for positioning ghost)
		$$invalidate(8, offsetY = grabbed.getBoundingClientRect().y - clientY);

		drag(clientY);
	};

	// drag handler updates cursor position
	const drag = clientY => {
		if (grabbed) {
			$$invalidate(7, mouseY = clientY);
			$$invalidate(9, layerY = ghost.parentNode.getBoundingClientRect().y);
		}
	};

	// touchEnter handler emulates the mouseenter event for touch input
	const touchEnter = ev => {
		drag(ev.clientY);

		// trigger dragEnter the first time the cursor moves over a list item
		let target = document.elementFromPoint(ev.clientX, ev.clientY).closest(".item-wrapper");

		if (target && target != lastTarget) {
			lastTarget = target;
			dragEnter(ev, target);
		}
	};

	const dragEnter = (ev, target) => {
		// swap items
		if (grabbed && target != grabbed && target.classList.contains("item-wrapper")) {
			moveItem(parseInt(grabbed.dataset.index), parseInt(target.dataset.index));
		}
	};

	// does the actual moving of items
	const moveItem = (from, to) => {
		let temp = field[from];
		$$invalidate(0, field[from] = field[to], field);
		$$invalidate(0, field[to] = temp, field);
	};

	const release = ev => {
		$$invalidate(6, grabbed = null);
	};

	const removeItem = val => {
		$$invalidate(0, field = field.filter(i => i !== val));
	};

	let textarea;
	let linkURL, linkText, linkOptions;

	const createLink = () => {
		$$invalidate(11, linkURL = prompt("Enter a URL:", "http://"));
		let selectedText = document.getSelection().toString();

		if (selectedText.length > 0) {
			$$invalidate(12, linkText = selectedText);
		} else {
			$$invalidate(12, linkText = prompt("Link Text:", ""));
		}

		let newTab = prompt("Open link in new tab? (yes/no)", "no");

		if (newTab === "yes" || newTab === "y") {
			$$invalidate(13, linkOptions = "target='_blank' rel='noreferrer noopener'");
		}
	};

	const input_handler = date => bindDate(date.target.value);

	function input_input_handler() {
		field = this.value;
		$$invalidate(0, field);
	}

	const click_handler = () => document.execCommand("bold");
	const click_handler_1 = () => document.execCommand("italic");
	const click_handler_2 = () => document.execCommand("underline");
	const click_handler_3 = () => document.execCommand("insertUnorderedList");
	const click_handler_4 = () => document.execCommand("insertOrderedList");
	const click_handler_5 = () => document.execCommand("insertHTML", false, "<a href='" + linkURL + "' " + linkOptions + ">" + linkText + "</a>");
	const click_handler_6 = () => document.execCommand("unlink");
	const click_handler_7 = () => document.execCommand("removeFormat");

	function div4_input_handler() {
		field = this.innerHTML;
		$$invalidate(0, field);
	}

	function div4_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			textarea = $$value;
			$$invalidate(10, textarea);
		});
	}

	function input_change_handler() {
		field = this.checked;
		$$invalidate(0, field);
	}

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			ghost = $$value;
			$$invalidate(5, ghost);
		});
	}

	const mousedown_handler = function (ev) {
		grab(ev.clientY, this.closest(".item-wrapper"));
	};

	const touchstart_handler = function (ev) {
		grab(ev.touches[0].clientY, this.closest(".item-wrapper"));
	};

	const mouseenter_handler = function (ev) {
		ev.stopPropagation();
		dragEnter(ev, ev.target.closest(".item-wrapper"));
	};

	const touchmove_handler = function (ev) {
		ev.stopPropagation();
		ev.preventDefault();
		touchEnter(ev.touches[0]);
	};

	const click_handler_8 = function (key, ev) {
		moveItem(key, key - 1);
	};

	const click_handler_9 = function (key, ev) {
		moveItem(key, key + 1);
	};

	const click_handler_10 = value => removeItem(value);

	function component_field_binding(value, key) {
		if ($$self.$$.not_equal(field[key], value)) {
			field[key] = value;
			$$invalidate(0, field);
		}
	}

	const mousemove_handler = function (ev) {
		ev.stopPropagation();
		drag(ev.clientY);
	};

	const touchmove_handler_1 = function (ev) {
		ev.stopPropagation();
		drag(ev.touches[0].clientY);
	};

	const mouseup_handler = function (ev) {
		ev.stopPropagation();
		release(ev);
	};

	const touchend_handler = function (ev) {
		ev.stopPropagation();
		release(ev.touches[0]);
	};

	function component_field_binding_1(value, key) {
		if ($$self.$$.not_equal(field[key], value)) {
			field[key] = value;
			$$invalidate(0, field);
		}
	}

	$$self.$$set = $$props => {
		if ("field" in $$props) $$invalidate(0, field = $$props.field);
		if ("label" in $$props) $$invalidate(1, label = $$props.label);
		if ("removesItems" in $$props) $$invalidate(2, removesItems = $$props.removesItems);
	};

	return [
		field,
		label,
		removesItems,
		isOpen,
		openKeys,
		ghost,
		grabbed,
		mouseY,
		offsetY,
		layerY,
		textarea,
		linkURL,
		linkText,
		linkOptions,
		bindDate,
		accordion,
		compID,
		grab,
		drag,
		touchEnter,
		dragEnter,
		moveItem,
		release,
		removeItem,
		createLink,
		input_handler,
		input_input_handler,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5,
		click_handler_6,
		click_handler_7,
		div4_input_handler,
		div4_binding,
		input_change_handler,
		div0_binding,
		mousedown_handler,
		touchstart_handler,
		mouseenter_handler,
		touchmove_handler,
		click_handler_8,
		click_handler_9,
		click_handler_10,
		component_field_binding,
		mousemove_handler,
		touchmove_handler_1,
		mouseup_handler,
		touchend_handler,
		component_field_binding_1
	];
}

class Component extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { field: 0, label: 1, removesItems: 2 }, [-1, -1]);
	}
}

export default Component;