/* generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	append,
	attr,
	children,
	claim_element,
	claim_space,
	destroy_each,
	detach,
	element,
	init,
	insert,
	is_function,
	listen,
	noop,
	safe_not_equal,
	space,
	svg_element
} from "svelte/internal";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

// (27:36) 
function create_if_block_2(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			this.h();
		},
		l(nodes) {
			img = claim_element(nodes, "IMG", { src: true, class: true });
			this.h();
		},
		h() {
			if (img.src !== (img_src_value = /*file*/ ctx[5])) attr(img, "src", img_src_value);
			attr(img, "class", "svelte-1dhihqp");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*files*/ 2 && img.src !== (img_src_value = /*file*/ ctx[5])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (25:12) {#if isPDF(file)}
function create_if_block_1(ctx) {
	let embed;
	let embed_src_value;

	return {
		c() {
			embed = element("embed");
			this.h();
		},
		l(nodes) {
			embed = claim_element(nodes, "EMBED", { src: true, type: true, class: true });
			this.h();
		},
		h() {
			if (embed.src !== (embed_src_value = /*file*/ ctx[5])) attr(embed, "src", embed_src_value);
			attr(embed, "type", "application/pdf");
			attr(embed, "class", "svelte-1dhihqp");
		},
		m(target, anchor) {
			insert(target, embed, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*files*/ 2 && embed.src !== (embed_src_value = /*file*/ ctx[5])) {
				attr(embed, "src", embed_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(embed);
		}
	};
}

// (30:12) {#if selectedMedia.includes(file)}
function create_if_block(ctx) {
	let svg;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg_nodes = children(svg);
			path0 = claim_element(svg_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path0).forEach(detach);
			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path1).forEach(detach);
			svg_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path0, "stroke", "none");
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(path1, "d", "M5 12l5 5l10 -10");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "icon icon-tabler icon-tabler-check svelte-1dhihqp");
			attr(svg, "width", "65");
			attr(svg, "height", "65");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke-width", "2.5");
			attr(svg, "stroke", "#1c7fc7");
			attr(svg, "fill", "none");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (23:4) {#each files as file}
function create_each_block(ctx) {
	let div;
	let show_if_1;
	let show_if_2;
	let t0;
	let show_if = /*selectedMedia*/ ctx[0].includes(/*file*/ ctx[5]);
	let t1;
	let div_class_value;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (show_if_1 == null || dirty & /*files*/ 2) show_if_1 = !!/*isPDF*/ ctx[3](/*file*/ ctx[5]);
		if (show_if_1) return create_if_block_1;
		if (show_if_2 == null || dirty & /*files*/ 2) show_if_2 = !!/*isImage*/ ctx[2](/*file*/ ctx[5]);
		if (show_if_2) return create_if_block_2;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block0 = current_block_type && current_block_type(ctx);
	let if_block1 = show_if && create_if_block(ctx);

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t1 = claim_space(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", div_class_value = "media" + (/*selectedMedia*/ ctx[0].includes(/*file*/ ctx[5])
			? " selected"
			: "") + " svelte-1dhihqp");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append(div, t0);
			if (if_block1) if_block1.m(div, null);
			append(div, t1);

			if (!mounted) {
				dispose = listen(div, "click", function () {
					if (is_function(/*selectMedia*/ ctx[4](/*file*/ ctx[5]))) /*selectMedia*/ ctx[4](/*file*/ ctx[5]).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if (if_block0) if_block0.d(1);
				if_block0 = current_block_type && current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div, t0);
				}
			}

			if (dirty & /*selectedMedia, files*/ 3) show_if = /*selectedMedia*/ ctx[0].includes(/*file*/ ctx[5]);

			if (show_if) {
				if (if_block1) {
					
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*selectedMedia, files*/ 3 && div_class_value !== (div_class_value = "media" + (/*selectedMedia*/ ctx[0].includes(/*file*/ ctx[5])
			? " selected"
			: "") + " svelte-1dhihqp")) {
				attr(div, "class", div_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);

			if (if_block0) {
				if_block0.d();
			}

			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let div;
	let each_value = /*files*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "media-browser svelte-1dhihqp");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*selectedMedia, files, selectMedia, isPDF, isImage*/ 31) {
				each_value = /*files*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { files } = $$props;
	let { selectedMedia = [] } = $$props;

	const isImage = file => {
		let extensions = ["jpg", "jpeg", "png", "webp", "gif", "svg", "avif", "apng"];
		let reImage = new RegExp("^data:image/(?:" + extensions.join("|") + ")(?:;charset=utf-8)?;base64,(?:[A-Za-z0-9]|[+/])+={0,2}");
		return extensions.includes(file.substr(file.lastIndexOf(".") + 1)) || reImage.test(file);
	};

	const isPDF = file => {
		let extensions = ["pdf", "msword"];
		let rePDF = new RegExp("^data:application/(?:" + extensions.join("|") + ")(?:;charset=utf-8)?;base64,(?:[A-Za-z0-9]|[+/])+={0,2}");
		return extensions.includes(file.substr(file.lastIndexOf(".") + 1)) || rePDF.test(file);
	};

	const selectMedia = file => {
		if (selectedMedia.includes(file)) {
			$$invalidate(0, selectedMedia = selectedMedia.filter(m => m !== file));
		} else {
			$$invalidate(0, selectedMedia = [...selectedMedia, file]);
		}
	};

	$$self.$$set = $$props => {
		if ("files" in $$props) $$invalidate(1, files = $$props.files);
		if ("selectedMedia" in $$props) $$invalidate(0, selectedMedia = $$props.selectedMedia);
	};

	return [selectedMedia, files, isImage, isPDF, selectMedia];
}

class Component extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { files: 1, selectedMedia: 0 });
	}
}

export default Component;